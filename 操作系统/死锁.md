# 一、四个必要条件

## 1.互斥条件

进程对于所分配到的资源具有排它性，即一个资源只能被一个进程占用，直到被该进程释放 。

## 2.请求与保持条件

一个进程因请求被占用资源而发生阻塞时，对已获得的资源保持不放。 

## 3.不剥夺条件

任何一个资源在没被该进程释放之前，任何其他进程都无法对他剥夺占用 

## 4.循环等待条件

当发生死锁时，所等待的进程必定会形成一个环路（类似于死循环），造成永久阻塞。

# 二、死锁处理

- 鸵鸟策略
- 死锁检测与死锁恢复
- 死锁预防
- 死锁避免

## 1.鸵鸟策略

把头埋在沙子里，假装根本没发生问题。

因为**解决死锁**问题的**代价很高**，因此鸵鸟策略这种**不采取任务措施**的方案会获得**更高的性能**。

当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。

大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。

## 2.死锁预防

在程序运行之前预防发生死锁。

### 破坏互斥条件

例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。

### 破坏占有和等待条件

一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。

### 破坏不可抢占条件

### 破坏环路等待

给资源统一编号，进程只能按编号顺序来请求资源。

# 三、死锁检测与死锁恢复

### 1.每种类型一个资源的死锁检测

每种类型一个资源的死锁检测算法是通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。

### 2.每种类型多个资源的死锁检测

- E 向量：资源总量
- A 向量：资源剩余量
- C 矩阵：每个进程所拥有的资源数量，每一行都代表一个进程拥有资源的数量
- R 矩阵：每个进程请求的资源数量

每个进程最开始时都不被标记，执行过程有可能被标记。当算法结束时，任何没有被标记的进程都是死锁进程。

1. 寻找一个没有标记的进程 Pi，它所请求的资源小于等于 A。

2. 如果找到了这样一个进程，那么将 C 矩阵的第 i 行向量加到 A 中，标记该进程，并转回 1。

3. 如果没有这样一个进程，算法终止。

### 3. 死锁恢复

   - 利用抢占恢复
   - 利用回滚恢复
   - 通过杀死进程恢复

# 四、死锁避免

### 银行家算法：

- 安全状态：如果存在一个由系统中所有进程构成的安全序列，则系统处于安全状态。安全状态一定是没有死锁发生。
- 不安全状态：不存在一个安全序列。不安全状态不一定导致死锁。

#### 银行家算法原理：

系统给当前进程分配资源时，先检查是否安全：

​	在满足当前进程X资源申请后，是否有足够的资源满足下一个距最大资源需求最近的进程（如某进程最大需要5个单位资源，已拥有1个，还尚需4个），若可以满足，则继续检查下一个距最大资源需求最近的进程，若均能满足所有进程，则表示为安全，允许给当前进程X分配所需资源，否则该进程X进入等待。检查过程中，每拟满足一个进程，则进行下个检查时，当前可用资源为回收上一个进程资源的总值，每满足一个进程表示此进程已结束，资源可回收。最终构成安全序列。

（注：检查过程中，每拟满足一个进程，则进行下个检查时，当前可用资源为回收上一个进程资源的总值，每满足一个进程表示此进程已结束，资源可回收。）