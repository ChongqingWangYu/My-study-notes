# JVM虚拟机

## 内存

-Xms设置内存初始化大小

-Xmx设置最大能够使用内存的大小

内存泄漏：由程序申请的一块内存，如果没有任何一个指针指向它，那么这块内存就泄漏了。

## 解释执行&编译执行

在Java编程语言和环境中，及时编译器（JIT compiler，just-in-time compiler）是一个把Java的字节码（.class）转换成可以直接发送给处理器的指令的程序。目前Java使用的是混合执行模式，部分函数会被解释执行，部分可能被编译执行。JVM决定函数是否需要编译执行的一句是判断该函数是否为热点代码。如果函数被调用频率高，那么就是热点，热点代码就会被编译执行。编译为机器码。

启用解释模式：Java -Xint -version

启用编译模式：Java -Xcomp -version

## 对象存活判断

- 引用计数：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。
- 可达性分析：从GC Roots开始向下搜索，搜索所走过的路径称为引用链，当一个对象没有任何引用链相连时，则此对象称为不可达对象，可以回收。

## 垃圾回收

随着系统运行时间的不断增长，垃圾对象所耗内存可能持续上升，直到出现内存溢出造成应用程序崩溃。

垃圾是指在运行程序中没有任何指针指向的对象。

## 碎片整理

由于创建对象和垃圾回收器释放丢弃对象所占的空间时，内存会因此出现碎片。碎片整理将所占用的堆内存移到堆的一端，以便JVM将整理出的内存分配给新的对象。

## 回收算法

1. 标记清除算法：第一次遍历，从根节点开始标记所有被引用的对象，第二次遍历，将所有未标记的对象回收。此算法需要暂停整个应用，且会产生内存碎片。
2. 复制算法：把内存空间划分为两个相等的区域，遍历当前使用区域，把正在使用的对象复制到另一个区域。此算法不会产生内存碎片，但需要两倍内存空间。
3. 标记整理算法：标记所有被引用对象，回收未标记对象并把存活对象“压缩”到堆的其中一块，按顺序排放。此算法不产生内存碎片，且不需要两倍内存空间。
4. 分代收集算法：基于统计结果并综合上面三个算法的优点。分为年轻代、老年代、永久代。

#### 年轻代&老年代

#### 规则

- 年轻代分1个Eden区和2个Survivor区

- 回收年轻代的行为被称为Minor GC。
- 回收老年代的行为被称为Major GC 或者 Full GC。
- 新创建的对象存放在年轻代（Eden区）。
- 大对象（需要分配的内存大于等于Eden区的一半）直接进入老年代。
- 因为大多数对象朝生夕死，为减少垃圾回收时的扫描范围，将生命周期短的对象存放在年轻代。
- Minor GC的发生频率比Full GC高很多，即年轻代发生垃圾回收的频率比老年代高。

#### 对象晋升

- 对象在Eden区经历一次Minor GC后仍然存活，且能被Survivor容纳则移动到Survivor区，同时年龄设为1。

- 对象在Survivor区经历一次Minor GC，年龄增加1岁，当年龄达到晋升阈值（MaxTenuringThreshold）就会晋升到老年代。

- Survivor空间中，年龄n的对象占用的内存总和大于Survivor空间的目标存活率（TargetSurvivorRatio），则年龄大于等于n的对象晋升为老年代。

#### 回收策略

每次Minor GC前，JVM会检查**老年代最大可用的连续空间**是否大于**年轻代所有对象的总空间**。

如果条件成立，则Minor GC是安全的，执行Minor GC。

如果不成立，则JVM查看HandlePromotionFailure是否允许担保失败。

如果允许担保失败，则检查老年代**最大可用的连续空间**是否大于**历次晋升到老年代对象的平均大小**。

如果大于，则进行一次Minor GC，尽管这次Minor GC是有风险的。

如果小于，或者HandlePromotionFailure设置不允许担保失败，则改为进行一次Full GC。

设置晋升阈值：-XX:MaxTenuringThreshold（默认为15）
设置Survivor目标存活率：-XX:TargetSurvivorRatio（默认为50）

#### 永久区（PermGen Space）

永久区又叫Perm区，是内存的永久保存区域，用于存放Class和Meta的信息。只存在于HotSpot JVM中，并且只存在于JDK 7和之前的版本中，JDK 8中已经彻底移除了永久区，JDK 8中引入了一个新的内存区域叫MetaSpace。