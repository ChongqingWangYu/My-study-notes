# 从输入URL地址到页面响应经历了什么？

## 一、域名解析

1. 将**域名**解析为**IP地址**，域名解析由**DNS服务器**完成。
2. IP地址是数字地址，不便于记忆。
3. 为了方便记忆，采用域名来代替IP地址标识站点地址。

## 二、建立TCP连接（三次握手）

​	TCP（传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，TCP层是位于**IP层之上**，**应用层之下**的中间层。

**TCP三次握手的过程如下：**

1. **客户端发送**SYN（SEQ=x）报文**给服务器端**，进入SYN_SEND状态。

2. **服务器端收到**SYN报文，**回应**一个SYN （SEQ=y）ACK(ACK=x+1）报文，进入[SYN_RECV](https://baike.baidu.com/item/SYN_RECV)状态。

3. **客户端收到**服务器端的SYN报文，**回应**一个ACK(ACK=y+1）报文，进入Established状态。

4. 三次**握手完成**，TCP客户端和服务器端成功地建立连接，可以开始**传输数据**了。

**问题1：SYN攻击**

SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server回复确认包，并等待Client的确认，由于源地址是不存在的，因此，Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起**网络堵塞**甚至**系统瘫痪**。SYN攻击是一种典型的**DDOS攻击**，检测SYN攻击的方式非常简单，即当Server上有**大量半连接状态且源IP地址是随机**的，则可以断定遭到SYN攻击了。

使用如下命令可以让之显形：netstat -nap | grep SYN_RECV

**SYN攻击防范技术主要有两大类：**

一类是通过**防火墙、路由器等过滤网关防护**。另一类是通过**加固TCP/IP协议栈防范**。

但必须清楚的是，**SYN攻击不能完全被阻止**，我们所做的是尽可能的减轻SYN攻击的危害，除非将TCP协议重新设计。

**问题2：为什么是三次握手**

（a）若两次握手，客户端收到服务端的应答后进入ESTABLISHED（已建立连接状态），而服务端在收到客户端的连接请求之后就进入了ESTABLISHED状态。如果出现网络拥塞，客户端发送的连接请求报文A过了很久没有到达服务端，会超时重发请求报文B，服务端正确接受并确认应答，连接建立并开始通信传输数据，等通信结束之后释放连接。此时，如果之前失效的连接请求A到达服务端，由于两次握手就能成功建立连接，服务端收到请求A之后进入ESTABLISHED已建立连接状态，等待发送数据或者主动发送数据，此时，客户端已经进入CLISED断开连接状态，服务器会一直等下去，浪费服务器连接资源。

（b）建立连接需要四次握手

由于三次握手已经能确保建立可靠的连接，所以不需要四次或更多的握手。

第三次握手主要是为了防止已失效的请求报文段突然又传送到了服务端而产生连接的误判 

**简单表述：为什么要三次握手？不是一次，两次或者四次。**

如果只有**一次握手**：a向b发起连接请求，假设b没收到，则b其实完全不知道a发起了请求，而a也完全不知道b收没收到，所以一次握手是不可靠的；

如果只有**两次握手**：a向b发起连接请求，b收到a的请求给a回复一个请求，假设此时a收到了b的回复，a知道了b已经就绪了，可b完全不知道a是否就绪，有可能a并没有收到b的请求，也有可能收到了，但这些b都完全不知道，所以只是单向的建立了连接；

如果**四次握手**：其实第两次握手已经让a知道b就绪了，第三次让b知道a也就绪了，第四次完全就是多余了，会浪费网络资源。

 **问题3：第三次握手失败时发生什么？**

当三次握手失败时服务器不会重传ack报文，而是直接发送RTS报文段，进入**CLOSED状态**。这样做是为了**防止SYN洪泛攻击**。

## 三、发起HTTP请求

### 1、HTTP

HTTP请求包括四个部分：

1. 请求行（request line）
2. 请求头部（header）
3. 空行
4. 请求数据

### 2、请求行 

请求行由三个字段组成：

- 请求方法字段
- URL字段
- HTTP协议版本字段

它们用空格分隔。例如：GET /index.html HTTP/1.1。

常见的七种请求方法：

1. GET: 完整请求一个资源 （常用）
2. HEAD: 仅请求响应首部
3. POST：提交表单 （常用）
4. PUT: (webdav) 上传文件（但是浏览器不支持该方法）
5. DELETE：(webdav) 删除
6. OPTIONS：返回请求的资源所支持的方法的方法
7. TRACE: 追求一个资源请求中间所经过的代理（该方法不能由浏览器发出）

### 3.请求头 

请求头由键值对组成，每行一对，关键字和值用英文冒号分隔。请求头部通知服务器有关于客户端请求的信息。

典型的请求头有：

- Accept：客户端可识别的内容类型列表。

- Accept-Encoding：声明浏览器支持的编码类型。

- Cache-Control：指定了请求和响应遵循的缓存机制。

- Connection：决定当前的事务完成后，是否会关闭网络连接。如果该值是“keep-alive”，网络连接就是持久

  的，不会关闭，使得对同一个服务器的请求可以继续在该连接上完成。

- Host：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机。

- Referer：告诉服务器从哪个页面链接过来的，服务器藉此可以获得一些信息用于处理。

- Upgrade-Insecure-Requests：让浏览器自动升级请求从http到https，用于大量包含http资源的http网页直接升级到https而不会报错。

- User-Agent：产生请求的浏览器类型。

### 3.空行 

最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头。

### 4.请求数据 

请求数据不在GET方法中使用，而是在POST方法中使用。POST方法适用于需要客户填写表单的场合。与请求数据相关的最常使用的请求头是Content-Type和Content-Length。



## 四、服务器收到请求并响应HTTP请求

HTTP响应由三个部分：

1. 状态行
2. 响应头部
3. 响应正文

### 1.状态行 

例：HTTP-Version Status-Code Reason-Phrase CRLF

- HTTP-Version：服务器HTTP协议版本
- Status-Code：服务器响应的状态代码
- Reason-Phrase：状态代码的文本描述

HTTP状态代由三位数字组成，共有五种类别：

1xx：指示信息–表示请求已接收，继续处理
2xx：成功–表示请求已被成功接收、理解、接受
3xx：重定向–要完成请求必须进行更进一步的操作
4xx：客户端错误–请求有语法错误或请求无法实现
5xx：服务器端错误–服务器未能实现合法的请求

常见状态代码：

- 200 OK：客户端**请求成功**
- 301: 永久重定向, Location响应首部的值仍为当前URL，因此为隐藏重定向
- 302: 临时重定向，显式重定向, Location响应首部的值为新的URL
- 304：Not Modified 未修改，比如本地缓存的资源文件和服务器上比较时，发现并没有修改，服务器返回一个304状态码，告诉浏览器，你不用请求该资源，直接使用本地的资源即可
- 400 Bad Request：客户端请求有语法错误，不能被服务器所理解
- 401 Unauthorized：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用
- 403 Forbidden：服务器**收到请求**，但**拒绝服务**
- 404 Not Found：请求**资源不存在**
- 500 Internal Server Error：服务器发生不可预期的错误
- 502: Bad Gateway ：充当网关或代理的服务器，从远端服务器接收到了一个无效的请求
- 503 Server Unavailable：由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中
- 504：Gateway Timeout ：代理服务器能联系后端服务器，但后端服务器未在规定时间内响应

### 2.响应头部 

Chrome浏览器响应头部： 

- 
  Connection：使用keep-alive特性

- Content-Encoding：使用gzip方式对资源压缩

- Content-type：MIME类型为html类型，字符集是 UTF-8

- Date：响应的日期

- Server：使用的WEB服务器

- Transfer-Encoding：用表示实体传输给用户的编码形式，包括：`chunked`、`compress`、 `deflate`、`gzip`、`identity`。

## 五、服务器返回响应HTML给客户端

## 六、断开TCP连接（四次挥手）

四次挥手：

1. TCP发送一个**FIN(结束)**，用来关闭客户到服务端的连接。

2. 服务端收到这个FIN，他发回一个**ACK(确认)**，确认收到序号为收到序号+1，和SYN一样，一个FIN将占用一个序号。

3. 服务端发送一个**FIN(结束)**到客户端，服务端关闭客户端的连接。

4. 客户端发送**ACK(确认)**报文确认，并将确认的序号+1，这样关闭完成。

**问题1：那么为什么是4次挥手呢？**

​	实际上两边连接完全可以分开看，用2次挥手断开其中一边连接，用另外2次挥手断开另一边的连接，最终完成整个连接关闭。之所以这样设计，是因为有可能某一边数据还未传输完，连接还未关闭。因为TCP被设计为全双工协议，可以任何一边单向发送数据。

**问题2：**   TCP握手的时候为何**ACK(确认)和SYN(建立连接)是一起发送**。挥手的时候为什么是分开的时候发送呢.

​	因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。

**问题3： 为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？**

​	第一，为了保证A发送的最后一个ACK报文能够到达B。这个ACK报文段有可能丢失，因而使处在LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认。B会超时重传这个FIN+ACK报文段，而A就能在2MSL时间内收到这个重传的FIN+ACK报文段。如果A在TIME-WAIT状态不等待一段时间，而是在发送完ACK报文段后就立即释放连接，就无法收到B重传的FIN+ACK报文段，因而也不会再发送一次确认报文段。这样，B就无法按照正常的步骤进入CLOSED状态。 
​	第二，A在发送完ACK报文段后，再经过2MSL时间，就可以使本连接持续的时间所产生的所有报文段都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求的报文段。

**问题4： TIME_WAIT与CLOSE_WAIT那个在客户端那个在服务端？**

​	主动发起关闭连接的一方为TIME_WAIT状态，被动的一方为CLOSE_WAIT状态。

## 七、浏览器解析HTML

## 八、浏览器渲染页面